// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

define("hawk.client", function () { return (function (modules) {
	var getModule, getRequire, require;
	getModule = (function (wrap) {
		return function (scope, tree, path, fullpath) {
			var name, dir, exports, module, fn, isDir;
			path = path.split('/');
			name = path.pop();
			if (!name) {
				isDir = true;
				name = path.pop();
			}
			if ((name === '.') || (name === '..')) {
				path.push(name);
				name = '';
			}
			while ((dir = path.shift())) {
				if (dir === '..') {
					scope = tree.pop();
				} else if (dir !== '.') {
					tree.push(scope);
					scope = scope[dir];
					if (!scope) {
						throw new Error("Could not find module '" + fullpath + "'");
					}
				}
			}
			if (name) {
				if (!isDir && scope[name + '.js']) {
					name += '.js';
				}
				if (typeof scope[name] === 'object') {
					tree.push(scope);
					scope = scope[name];
					name = 'index.js';
				}
			} else {
				name = 'index.js';
			}
			fn = scope[name];
			if (!fn) throw new Error("Could not find module '" + fullpath + "'");
			if (fn.hasOwnProperty('module')) return fn.module.exports;
			exports = {};
			fn.module = module = { exports: exports };
			fn.call(exports, exports, module, getRequire(scope, tree));
			return module.exports;
		};
	}(function (cmodule) {
		return function (ignore, module) {
			module.exports = cmodule.exports;
		};
	}));
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0);
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			tree = [];
			path = path.slice(name.length + 1) || scope[':mainpath:'];
		}
		return getModule(scope, tree, path, fullpath);
	};
	getRequire = function (scope, tree) {
		return function (path) {
			return require(scope, [].concat(tree), path);
		};
	};
	return getRequire(modules, []);
})({
	"hawk": {
		"index.js": function (exports, module, require) {
			module.exports = require('./lib/hawk');
		},
		"lib": {
			"crypto.js": function (exports, module, require) {
				var HttpError = require('./httpError'),
				    Crypto = require('./cryptoJS'),
				    Utils = require('./utils');


				// MAC normalization format version

				exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats


				// Supported HMAC algorithms

				exports.algorithms = ['SHA1', 'SHA256'];


				// Calculate the request MAC

				/*
				    options = {
				        type: 'header',                             // 'header', 'bewit'
				        key: 'aoijedoaijsdlaksjdl',
				        algorithm: 'sha256',                        // 'sha1', 'sha256'
				        timestamp: 1357718381034,
				        nonce: 'd3d345f',
				        method: 'GET',
				        uri: '/resource?a=1&b=2',
				        host: 'example.com',
				        port: 8080,
				        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
				        ext: 'app-specific-data'
				    };
				*/

				exports.calculateMac = function (options) {

				    var normalized = exports.generateNormalizedString(options);
				    
				    var hmac = Crypto.algo.HMAC.create(Crypto.algo[options.algorithm], options.key).finalize(normalized);
				    var digest = hmac.toString(Crypto.enc.Base64);
				    return digest;
				};


				exports.generateNormalizedString = function (options) {

				    // skrip trailing '?'
				    var uri = options.uri.split('?')[0];

				    var normalized = 'hawk.' + exports.headerVersion + '.' + options.type + '\n' +
				                     options.timestamp + '\n' +
				                     options.nonce + '\n' +
				                     options.method.toUpperCase() + '\n' +
				                     uri + '\n' + 
				                     options.host.toLowerCase() + '\n' +
				                     options.port + '\n' +
				                     (options.hash || '') + '\n' +
				                     (options.ext || '') + '\n';

				    return normalized;
				};


				exports.calculateHash = function (payload, algorithm) {

				    if(!Crypto.hasOwnProperty(algorithm) || 
				        typeof Crypto[algorithm] !== 'function') throw "Unsupported crypto: " + algorithm;

				    var hash = Crypto[algorithm](payload);
				    var digest = hash.toString(Crypto.enc.Base64);
				    return digest;
				};

				function toBase64String(buffer) {
				    return Crypto.enc.Utf8.parse(buffer).toString(Crypto.enc.Base64);
				}

				// Base64url (RFC 4648) encode

				exports.base64urlEncode = function (value) {

				    return toBase64String(value).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
				};


				// Base64url (RFC 4648) decode

				exports.base64urlDecode = function (encoded) {

				    if (encoded &&
				        !encoded.match(/^[\w\-]*$/)) {

				        return new Error('Invalid character');
				    }

				    try {
				        return Crypto.enc.Base64.parse(encoded.replace(/-/g, '+').replace(/:/g, '/')).words;
				    }
				    catch (err) {
				        return err;
				    }
				};

				exports.randomBytes = function(n,callback){
				    var bytes = [];

				    if(typeof window === 'object' && window.crypto && window.crypto.getRandomValues) {
				        var buf = new Uint8Array(n);
				        window.crypto.getRandomValues(buf);

				        for (var i = 0; i < n; i++)
				            bytes.push(buf[i]);
				    } else {
				        for (var bytes = []; n > 0; n--)
				            bytes.push(Math.floor(Math.random() * 256));
				    }
				    /* todo: add support for other randomizers */

				    if(callback) callback(bytes);

				    return bytes;
				}

				exports.randomString = function (size) {

				    var buffer = exports.randomBits((size + 1) * 6);
				    if (buffer instanceof Error) {
				        return buffer;
				    }

				    var string = toBase64String(buffer).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
				    return string.slice(0, size);
				};


				exports.randomBits = function (bits) {

				    if (!bits ||
				        bits < 0) {

				        return HttpError.internal('Invalid random bits count');
				    }

				    var bytes = Math.ceil(bits / 8);
				    try {
				        return exports.randomBytes(bytes);
				    }
				    catch (err) {
				        return HttpError.internal('Failed generating random bits: ' + err.message);
				    }
				};


				// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)

				exports.fixedTimeComparison = function (a, b) {

				    var mismatch = (a.length === b.length ? 0 : 1);
				    if (mismatch) {
				        b = a;
				    }

				    for (var i = 0, il = a.length; i < il; ++i) {
				        var ac = a.charCodeAt(i);
				        var bc = b.charCodeAt(i);
				        mismatch += (ac === bc ? 0 : 1);
				    }

				    return (mismatch === 0);
				};
			},
			"cryptoJS.js": function (exports, module, require) {
				/*
				CryptoJS v3.1.2
				code.google.com/p/crypto-js
				(c) 2009-2013 by Jeff Mott. All rights reserved.
				code.google.com/p/crypto-js/wiki/License
				*/
				/**
				 * CryptoJS core components.
				 */
				var CryptoJS = exports = module.exports = CryptoJS || (function (Math, undefined) {
				    /**
				     * CryptoJS namespace.
				     */
				    var C = {};

				    /**
				     * Library namespace.
				     */
				    var C_lib = C.lib = {};

				    /**
				     * Base object for prototypal inheritance.
				     */
				    var Base = C_lib.Base = (function () {
				        function F() {}

				        return {
				            /**
				             * Creates a new object that inherits from this object.
				             *
				             * @param {Object} overrides Properties to copy into the new object.
				             *
				             * @return {Object} The new object.
				             *
				             * @static
				             *
				             * @example
				             *
				             *     var MyType = CryptoJS.lib.Base.extend({
				             *         field: 'value',
				             *
				             *         method: function () {
				             *         }
				             *     });
				             */
				            extend: function (overrides) {
				                // Spawn
				                F.prototype = this;
				                var subtype = new F();

				                // Augment
				                if (overrides) {
				                    subtype.mixIn(overrides);
				                }

				                // Create default initializer
				                if (!subtype.hasOwnProperty('init')) {
				                    subtype.init = function () {
				                        subtype.$super.init.apply(this, arguments);
				                    };
				                }

				                // Initializer's prototype is the subtype object
				                subtype.init.prototype = subtype;

				                // Reference supertype
				                subtype.$super = this;

				                return subtype;
				            },

				            /**
				             * Extends this object and runs the init method.
				             * Arguments to create() will be passed to init().
				             *
				             * @return {Object} The new object.
				             *
				             * @static
				             *
				             * @example
				             *
				             *     var instance = MyType.create();
				             */
				            create: function () {
				                var instance = this.extend();
				                instance.init.apply(instance, arguments);

				                return instance;
				            },

				            /**
				             * Initializes a newly created object.
				             * Override this method to add some logic when your objects are created.
				             *
				             * @example
				             *
				             *     var MyType = CryptoJS.lib.Base.extend({
				             *         init: function () {
				             *             // ...
				             *         }
				             *     });
				             */
				            init: function () {
				            },

				            /**
				             * Copies properties into this object.
				             *
				             * @param {Object} properties The properties to mix in.
				             *
				             * @example
				             *
				             *     MyType.mixIn({
				             *         field: 'value'
				             *     });
				             */
				            mixIn: function (properties) {
				                for (var propertyName in properties) {
				                    if (properties.hasOwnProperty(propertyName)) {
				                        this[propertyName] = properties[propertyName];
				                    }
				                }

				                // IE won't copy toString using the loop above
				                if (properties.hasOwnProperty('toString')) {
				                    this.toString = properties.toString;
				                }
				            },

				            /**
				             * Creates a copy of this object.
				             *
				             * @return {Object} The clone.
				             *
				             * @example
				             *
				             *     var clone = instance.clone();
				             */
				            clone: function () {
				                return this.init.prototype.extend(this);
				            }
				        };
				    }());

				    /**
				     * An array of 32-bit words.
				     *
				     * @property {Array} words The array of 32-bit words.
				     * @property {number} sigBytes The number of significant bytes in this word array.
				     */
				    var WordArray = C_lib.WordArray = Base.extend({
				        /**
				         * Initializes a newly created word array.
				         *
				         * @param {Array} words (Optional) An array of 32-bit words.
				         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.lib.WordArray.create();
				         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
				         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
				         */
				        init: function (words, sigBytes) {
				            words = this.words = words || [];

				            if (sigBytes != undefined) {
				                this.sigBytes = sigBytes;
				            } else {
				                this.sigBytes = words.length * 4;
				            }
				        },

				        /**
				         * Converts this word array to a string.
				         *
				         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
				         *
				         * @return {string} The stringified word array.
				         *
				         * @example
				         *
				         *     var string = wordArray + '';
				         *     var string = wordArray.toString();
				         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
				         */
				        toString: function (encoder) {
				            return (encoder || Hex).stringify(this);
				        },

				        /**
				         * Concatenates a word array to this word array.
				         *
				         * @param {WordArray} wordArray The word array to append.
				         *
				         * @return {WordArray} This word array.
				         *
				         * @example
				         *
				         *     wordArray1.concat(wordArray2);
				         */
				        concat: function (wordArray) {
				            // Shortcuts
				            var thisWords = this.words;
				            var thatWords = wordArray.words;
				            var thisSigBytes = this.sigBytes;
				            var thatSigBytes = wordArray.sigBytes;

				            // Clamp excess bits
				            this.clamp();

				            // Concat
				            if (thisSigBytes % 4) {
				                // Copy one byte at a time
				                for (var i = 0; i < thatSigBytes; i++) {
				                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
				                }
				            } else if (thatWords.length > 0xffff) {
				                // Copy one word at a time
				                for (var i = 0; i < thatSigBytes; i += 4) {
				                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
				                }
				            } else {
				                // Copy all words at once
				                thisWords.push.apply(thisWords, thatWords);
				            }
				            this.sigBytes += thatSigBytes;

				            // Chainable
				            return this;
				        },

				        /**
				         * Removes insignificant bits.
				         *
				         * @example
				         *
				         *     wordArray.clamp();
				         */
				        clamp: function () {
				            // Shortcuts
				            var words = this.words;
				            var sigBytes = this.sigBytes;

				            // Clamp
				            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
				            words.length = Math.ceil(sigBytes / 4);
				        },

				        /**
				         * Creates a copy of this word array.
				         *
				         * @return {WordArray} The clone.
				         *
				         * @example
				         *
				         *     var clone = wordArray.clone();
				         */
				        clone: function () {
				            var clone = Base.clone.call(this);
				            clone.words = this.words.slice(0);

				            return clone;
				        },

				        /**
				         * Creates a word array filled with random bytes.
				         *
				         * @param {number} nBytes The number of random bytes to generate.
				         *
				         * @return {WordArray} The random word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.lib.WordArray.random(16);
				         */
				        random: function (nBytes) {
				            var words = [];
				            for (var i = 0; i < nBytes; i += 4) {
				                words.push((Math.random() * 0x100000000) | 0);
				            }

				            return new WordArray.init(words, nBytes);
				        }
				    });

				    /**
				     * Encoder namespace.
				     */
				    var C_enc = C.enc = {};

				    /**
				     * Hex encoding strategy.
				     */
				    var Hex = C_enc.Hex = {
				        /**
				         * Converts a word array to a hex string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The hex string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var hexChars = [];
				            for (var i = 0; i < sigBytes; i++) {
				                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                hexChars.push((bite >>> 4).toString(16));
				                hexChars.push((bite & 0x0f).toString(16));
				            }

				            return hexChars.join('');
				        },

				        /**
				         * Converts a hex string to a word array.
				         *
				         * @param {string} hexStr The hex string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
				         */
				        parse: function (hexStr) {
				            // Shortcut
				            var hexStrLength = hexStr.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < hexStrLength; i += 2) {
				                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
				            }

				            return new WordArray.init(words, hexStrLength / 2);
				        }
				    };

				    /**
				     * Latin1 encoding strategy.
				     */
				    var Latin1 = C_enc.Latin1 = {
				        /**
				         * Converts a word array to a Latin1 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The Latin1 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var latin1Chars = [];
				            for (var i = 0; i < sigBytes; i++) {
				                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                latin1Chars.push(String.fromCharCode(bite));
				            }

				            return latin1Chars.join('');
				        },

				        /**
				         * Converts a Latin1 string to a word array.
				         *
				         * @param {string} latin1Str The Latin1 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
				         */
				        parse: function (latin1Str) {
				            // Shortcut
				            var latin1StrLength = latin1Str.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < latin1StrLength; i++) {
				                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
				            }

				            return new WordArray.init(words, latin1StrLength);
				        }
				    };

				    /**
				     * UTF-8 encoding strategy.
				     */
				    var Utf8 = C_enc.Utf8 = {
				        /**
				         * Converts a word array to a UTF-8 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The UTF-8 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            try {
				                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
				            } catch (e) {
				                throw new Error('Malformed UTF-8 data');
				            }
				        },

				        /**
				         * Converts a UTF-8 string to a word array.
				         *
				         * @param {string} utf8Str The UTF-8 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
				         */
				        parse: function (utf8Str) {
				            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
				        }
				    };

				    /**
				     * Abstract buffered block algorithm template.
				     *
				     * The property blockSize must be implemented in a concrete subtype.
				     *
				     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
				     */
				    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
				        /**
				         * Resets this block algorithm's data buffer to its initial state.
				         *
				         * @example
				         *
				         *     bufferedBlockAlgorithm.reset();
				         */
				        reset: function () {
				            // Initial values
				            this._data = new WordArray.init();
				            this._nDataBytes = 0;
				        },

				        /**
				         * Adds new data to this block algorithm's buffer.
				         *
				         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
				         *
				         * @example
				         *
				         *     bufferedBlockAlgorithm._append('data');
				         *     bufferedBlockAlgorithm._append(wordArray);
				         */
				        _append: function (data) {
				            // Convert string to WordArray, else assume WordArray already
				            if (typeof data == 'string') {
				                data = Utf8.parse(data);
				            }

				            // Append
				            this._data.concat(data);
				            this._nDataBytes += data.sigBytes;
				        },

				        /**
				         * Processes available data blocks.
				         *
				         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
				         *
				         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
				         *
				         * @return {WordArray} The processed data.
				         *
				         * @example
				         *
				         *     var processedData = bufferedBlockAlgorithm._process();
				         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
				         */
				        _process: function (doFlush) {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;
				            var dataSigBytes = data.sigBytes;
				            var blockSize = this.blockSize;
				            var blockSizeBytes = blockSize * 4;

				            // Count blocks ready
				            var nBlocksReady = dataSigBytes / blockSizeBytes;
				            if (doFlush) {
				                // Round up to include partial blocks
				                nBlocksReady = Math.ceil(nBlocksReady);
				            } else {
				                // Round down to include only full blocks,
				                // less the number of blocks that must remain in the buffer
				                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
				            }

				            // Count words ready
				            var nWordsReady = nBlocksReady * blockSize;

				            // Count bytes ready
				            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

				            // Process blocks
				            if (nWordsReady) {
				                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
				                    // Perform concrete-algorithm logic
				                    this._doProcessBlock(dataWords, offset);
				                }

				                // Remove processed words
				                var processedWords = dataWords.splice(0, nWordsReady);
				                data.sigBytes -= nBytesReady;
				            }

				            // Return processed words
				            return new WordArray.init(processedWords, nBytesReady);
				        },

				        /**
				         * Creates a copy of this object.
				         *
				         * @return {Object} The clone.
				         *
				         * @example
				         *
				         *     var clone = bufferedBlockAlgorithm.clone();
				         */
				        clone: function () {
				            var clone = Base.clone.call(this);
				            clone._data = this._data.clone();

				            return clone;
				        },

				        _minBufferSize: 0
				    });

				    /**
				     * Abstract hasher template.
				     *
				     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
				     */
				    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
				        /**
				         * Configuration options.
				         */
				        cfg: Base.extend(),

				        /**
				         * Initializes a newly created hasher.
				         *
				         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
				         *
				         * @example
				         *
				         *     var hasher = CryptoJS.algo.SHA256.create();
				         */
				        init: function (cfg) {
				            // Apply config defaults
				            this.cfg = this.cfg.extend(cfg);

				            // Set initial values
				            this.reset();
				        },

				        /**
				         * Resets this hasher to its initial state.
				         *
				         * @example
				         *
				         *     hasher.reset();
				         */
				        reset: function () {
				            // Reset data buffer
				            BufferedBlockAlgorithm.reset.call(this);

				            // Perform concrete-hasher logic
				            this._doReset();
				        },

				        /**
				         * Updates this hasher with a message.
				         *
				         * @param {WordArray|string} messageUpdate The message to append.
				         *
				         * @return {Hasher} This hasher.
				         *
				         * @example
				         *
				         *     hasher.update('message');
				         *     hasher.update(wordArray);
				         */
				        update: function (messageUpdate) {
				            // Append
				            this._append(messageUpdate);

				            // Update the hash
				            this._process();

				            // Chainable
				            return this;
				        },

				        /**
				         * Finalizes the hash computation.
				         * Note that the finalize operation is effectively a destructive, read-once operation.
				         *
				         * @param {WordArray|string} messageUpdate (Optional) A final message update.
				         *
				         * @return {WordArray} The hash.
				         *
				         * @example
				         *
				         *     var hash = hasher.finalize();
				         *     var hash = hasher.finalize('message');
				         *     var hash = hasher.finalize(wordArray);
				         */
				        finalize: function (messageUpdate) {
				            // Final message update
				            if (messageUpdate) {
				                this._append(messageUpdate);
				            }

				            // Perform concrete-hasher logic
				            var hash = this._doFinalize();

				            return hash;
				        },

				        blockSize: 512/32,

				        /**
				         * Creates a shortcut function to a hasher's object interface.
				         *
				         * @param {Hasher} hasher The hasher to create a helper for.
				         *
				         * @return {Function} The shortcut function.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
				         */
				        _createHelper: function (hasher) {
				            return function (message, cfg) {
				                return new hasher.init(cfg).finalize(message);
				            };
				        },

				        /**
				         * Creates a shortcut function to the HMAC's object interface.
				         *
				         * @param {Hasher} hasher The hasher to use in this HMAC helper.
				         *
				         * @return {Function} The shortcut function.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
				         */
				        _createHmacHelper: function (hasher) {
				            return function (message, key) {
				                return new C_algo.HMAC.init(hasher, key).finalize(message);
				            };
				        }
				    });

				    /**
				     * Algorithm namespace.
				     */
				    var C_algo = C.algo = {};

				    return C;
				}(Math));


				/* Base64 */
				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var C_enc = C.enc;

				    /**
				     * Base64 encoding strategy.
				     */
				    var Base64 = C_enc.Base64 = {
				        /**
				         * Converts a word array to a Base64 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The Base64 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;
				            var map = this._map;

				            // Clamp excess bits
				            wordArray.clamp();

				            // Convert
				            var base64Chars = [];
				            for (var i = 0; i < sigBytes; i += 3) {
				                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
				                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
				                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

				                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

				                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
				                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
				                }
				            }

				            // Add padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                while (base64Chars.length % 4) {
				                    base64Chars.push(paddingChar);
				                }
				            }

				            return base64Chars.join('');
				        },

				        /**
				         * Converts a Base64 string to a word array.
				         *
				         * @param {string} base64Str The Base64 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
				         */
				        parse: function (base64Str) {
				            // Shortcuts
				            var base64StrLength = base64Str.length;
				            var map = this._map;

				            // Ignore padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                var paddingIndex = base64Str.indexOf(paddingChar);
				                if (paddingIndex != -1) {
				                    base64StrLength = paddingIndex;
				                }
				            }

				            // Convert
				            var words = [];
				            var nBytes = 0;
				            for (var i = 0; i < base64StrLength; i++) {
				                if (i % 4) {
				                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
				                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
				                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
				                    nBytes++;
				                }
				            }

				            return WordArray.create(words, nBytes);
				        },

				        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
				    };
				}());

				/* HMAC */
				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var C_enc = C.enc;
				    var Utf8 = C_enc.Utf8;
				    var C_algo = C.algo;

				    /**
				     * HMAC algorithm.
				     */
				    var HMAC = C_algo.HMAC = Base.extend({
				        /**
				         * Initializes a newly created HMAC.
				         *
				         * @param {Hasher} hasher The hash algorithm to use.
				         * @param {WordArray|string} key The secret key.
				         *
				         * @example
				         *
				         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
				         */
				        init: function (hasher, key) {
				            // Init hasher
				            hasher = this._hasher = new hasher.init();

				            // Convert string to WordArray, else assume WordArray already
				            if (typeof key == 'string') {
				                key = Utf8.parse(key);
				            }

				            // Shortcuts
				            var hasherBlockSize = hasher.blockSize;
				            var hasherBlockSizeBytes = hasherBlockSize * 4;

				            // Allow arbitrary length keys
				            if (key.sigBytes > hasherBlockSizeBytes) {
				                key = hasher.finalize(key);
				            }

				            // Clamp excess bits
				            key.clamp();

				            // Clone key for inner and outer pads
				            var oKey = this._oKey = key.clone();
				            var iKey = this._iKey = key.clone();

				            // Shortcuts
				            var oKeyWords = oKey.words;
				            var iKeyWords = iKey.words;

				            // XOR keys with pad constants
				            for (var i = 0; i < hasherBlockSize; i++) {
				                oKeyWords[i] ^= 0x5c5c5c5c;
				                iKeyWords[i] ^= 0x36363636;
				            }
				            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

				            // Set initial values
				            this.reset();
				        },

				        /**
				         * Resets this HMAC to its initial state.
				         *
				         * @example
				         *
				         *     hmacHasher.reset();
				         */
				        reset: function () {
				            // Shortcut
				            var hasher = this._hasher;

				            // Reset
				            hasher.reset();
				            hasher.update(this._iKey);
				        },

				        /**
				         * Updates this HMAC with a message.
				         *
				         * @param {WordArray|string} messageUpdate The message to append.
				         *
				         * @return {HMAC} This HMAC instance.
				         *
				         * @example
				         *
				         *     hmacHasher.update('message');
				         *     hmacHasher.update(wordArray);
				         */
				        update: function (messageUpdate) {
				            this._hasher.update(messageUpdate);

				            // Chainable
				            return this;
				        },

				        /**
				         * Finalizes the HMAC computation.
				         * Note that the finalize operation is effectively a destructive, read-once operation.
				         *
				         * @param {WordArray|string} messageUpdate (Optional) A final message update.
				         *
				         * @return {WordArray} The HMAC.
				         *
				         * @example
				         *
				         *     var hmac = hmacHasher.finalize();
				         *     var hmac = hmacHasher.finalize('message');
				         *     var hmac = hmacHasher.finalize(wordArray);
				         */
				        finalize: function (messageUpdate) {
				            // Shortcut
				            var hasher = this._hasher;

				            // Compute HMAC
				            var innerHash = hasher.finalize(messageUpdate);
				            hasher.reset();
				            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

				            return hmac;
				        }
				    });
				}());

				/* SHA1 */
				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Reusable object
				    var W = [];

				    /**
				     * SHA-1 hash algorithm.
				     */
				    var SHA1 = C_algo.SHA1 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init([
				                0x67452301, 0xefcdab89,
				                0x98badcfe, 0x10325476,
				                0xc3d2e1f0
				            ]);
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var H = this._hash.words;

				            // Working variables
				            var a = H[0];
				            var b = H[1];
				            var c = H[2];
				            var d = H[3];
				            var e = H[4];

				            // Computation
				            for (var i = 0; i < 80; i++) {
				                if (i < 16) {
				                    W[i] = M[offset + i] | 0;
				                } else {
				                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
				                    W[i] = (n << 1) | (n >>> 31);
				                }

				                var t = ((a << 5) | (a >>> 27)) + e + W[i];
				                if (i < 20) {
				                    t += ((b & c) | (~b & d)) + 0x5a827999;
				                } else if (i < 40) {
				                    t += (b ^ c ^ d) + 0x6ed9eba1;
				                } else if (i < 60) {
				                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
				                } else /* if (i < 80) */ {
				                    t += (b ^ c ^ d) - 0x359d3e2a;
				                }

				                e = d;
				                d = c;
				                c = (b << 30) | (b >>> 2);
				                b = a;
				                a = t;
				            }

				            // Intermediate hash value
				            H[0] = (H[0] + a) | 0;
				            H[1] = (H[1] + b) | 0;
				            H[2] = (H[2] + c) | 0;
				            H[3] = (H[3] + d) | 0;
				            H[4] = (H[4] + e) | 0;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Return final computed hash
				            return this._hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA1('message');
				     *     var hash = CryptoJS.SHA1(wordArray);
				     */
				    C.SHA1 = Hasher._createHelper(SHA1);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA1(message, key);
				     */
				    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
				}());

				/* SHA256 */
				(function (Math) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Initialization and round constants tables
				    var H = [];
				    var K = [];

				    // Compute constants
				    (function () {
				        function isPrime(n) {
				            var sqrtN = Math.sqrt(n);
				            for (var factor = 2; factor <= sqrtN; factor++) {
				                if (!(n % factor)) {
				                    return false;
				                }
				            }

				            return true;
				        }

				        function getFractionalBits(n) {
				            return ((n - (n | 0)) * 0x100000000) | 0;
				        }

				        var n = 2;
				        var nPrime = 0;
				        while (nPrime < 64) {
				            if (isPrime(n)) {
				                if (nPrime < 8) {
				                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
				                }
				                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

				                nPrime++;
				            }

				            n++;
				        }
				    }());

				    // Reusable object
				    var W = [];

				    /**
				     * SHA-256 hash algorithm.
				     */
				    var SHA256 = C_algo.SHA256 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init(H.slice(0));
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var H = this._hash.words;

				            // Working variables
				            var a = H[0];
				            var b = H[1];
				            var c = H[2];
				            var d = H[3];
				            var e = H[4];
				            var f = H[5];
				            var g = H[6];
				            var h = H[7];

				            // Computation
				            for (var i = 0; i < 64; i++) {
				                if (i < 16) {
				                    W[i] = M[offset + i] | 0;
				                } else {
				                    var gamma0x = W[i - 15];
				                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
				                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
				                                   (gamma0x >>> 3);

				                    var gamma1x = W[i - 2];
				                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
				                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
				                                   (gamma1x >>> 10);

				                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
				                }

				                var ch  = (e & f) ^ (~e & g);
				                var maj = (a & b) ^ (a & c) ^ (b & c);

				                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
				                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

				                var t1 = h + sigma1 + ch + K[i] + W[i];
				                var t2 = sigma0 + maj;

				                h = g;
				                g = f;
				                f = e;
				                e = (d + t1) | 0;
				                d = c;
				                c = b;
				                b = a;
				                a = (t1 + t2) | 0;
				            }

				            // Intermediate hash value
				            H[0] = (H[0] + a) | 0;
				            H[1] = (H[1] + b) | 0;
				            H[2] = (H[2] + c) | 0;
				            H[3] = (H[3] + d) | 0;
				            H[4] = (H[4] + e) | 0;
				            H[5] = (H[5] + f) | 0;
				            H[6] = (H[6] + g) | 0;
				            H[7] = (H[7] + h) | 0;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Return final computed hash
				            return this._hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA256('message');
				     *     var hash = CryptoJS.SHA256(wordArray);
				     */
				    C.SHA256 = Hasher._createHelper(SHA256);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA256(message, key);
				     */
				    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
				}(Math));

			},
			"hawk.js": function (exports, module, require) {
				/* This is a port of the huinverse/hawk nodejs authentication framework to ArangoDB */

				var HttpError = require('./httpError'),
				    Crypto = require('./crypto'),
				    Utils = require('./utils');


				// Export sub-modules
				exports.version = "0.7.1";
				exports.crypto = Crypto;
				exports.error = exports.Error = HttpError;
				exports.utils = Utils;


				// Hawk authentication

				/*
				 * req                - node's HTTP request object or an object as follows:
				 *
				 *                      var request = {
				 *                          method: 'GET',
				 *                          url: '/resource/4?a=1&b=2',
				 *                          host: 'example.com',
				 *                          port: 8080,
				 *                          authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
				 *                      };
				 *
				 * credentialsFunc    - required function to lookup the set of Hawk credentials based on the provided credentials id.
				 *                      The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
				 *                      needed by the application. This function is the equivalent of verifying the username and
				 *                      password in Basic authentication.
				 *
				 *                      var credentialsFunc = function (id, callback) {
				 *  
				 *                          // Lookup credentials in database
				 *                          db.lookup(id, function (err, item) {
				 *  
				 *                              if (err || !item) {
				 *                                  return callback(err);
				 *                              }
				 *  
				 *                              var credentials = {
				 *                                  // Required
				 *                                  key: item.key,
				 *                                  algorithm: item.algorithm,
				 *                                  // Application specific
				 *                                  user: item.user
				 *                              };
				 *  
				 *                              return callback(null, credentials);
				 *                          });
				 *                      };
				 *
				 * options:
				 * 
				 * hostHeaderName       - optional header field name, used to override the default 'Host' header when used
				 *                        behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
				 *                        the original (which is what the module must verify) in the 'x-forwarded-host' header field.
				 *                        Only used when passed a node Http.ServerRequest object.
				 *
				 * nonceFunc            - optional nonce validation function. The function signature is function(nonce, ts, callback)
				 *                        where 'callback' must be called using the signature function(err).
				 *
				 * timestampSkewSec     - optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
				 *                        Provides a +/- skew which means actual allowed window is double the number of seconds.
				 *
				 * localtimeOffsetMsec  - optional local clock time offset express in a number of milliseconds (positive or negative).
				 *                        Defaults to 0.
				 *
				 * payload              - optional payload for validation. The client calculates the hash value and includes it via the 'hash'
				 *                        header attribute. The server always ensures the value provided has been included in the request
				 *                        MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
				 *                        a hash value over the entire payload (assuming it has already be normalized to the same format and
				 *                        encoding used by the client to calculate the hash on request). If the payload is not available at the time
				 *                        of authentication, the validatePayload() method can be used by passing it the credentials and
				 *                        attributes.hash returned in the authenticate callback.
				 */

				exports.authenticate = function (req, credentialsFunc, options, callback) {

				    // Default options

				    options.nonceFunc = options.nonceFunc || function (nonce, ts, callback) { return callback(); };         // No validation
				    options.timestampSkewSec = options.timestampSkewSec || 60;                                              // 60 seconds

				    // Application time

				    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

				    // Convert node Http request object to a request configuration object

				    var request = Utils.parseRequest(req, options);
				    if (request instanceof Error) {
				        return callback(HttpError.badRequest(request.message));
				    }

				    // Parse HTTP Authorization header

				    if (!request.authorization) {
				        return callback(HttpError.unauthorized(null, 'Hawk', { ts: now }));
				    }

				    var headerParts = request.authorization.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
				    if (!headerParts) {
				        return callback(HttpError.badRequest('Invalid header syntax'));
				    }

				    var scheme = headerParts[1];
				    if (scheme.toLowerCase() !== 'hawk') {
				        return callback(HttpError.unauthorized(null, 'Hawk', { ts: now }));
				    }

				    var attributesString = headerParts[2];
				    if (!attributesString) {
				        return callback(HttpError.badRequest('Invalid header syntax'));
				    }

				    var attributes = {};
				    var errorMessage = '';
				    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

				        // Check valid attribute names

				        if (['id', 'ts', 'nonce', 'hash', 'ext', 'mac'].indexOf($1) === -1) {
				            errorMessage = 'Unknown attribute: ' + $1;
				            return;
				        }

				        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

				        if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
				            errorMessage = 'Bad attribute value: ' + $1;
				            return;
				        }

				        // Check for duplicates

				        if (attributes.hasOwnProperty($1)) {
				            errorMessage = 'Duplicate attribute: ' + $1;
				            return;
				        }

				        attributes[$1] = $2;
				        return '';
				    });

				    if (verify !== '') {
				        return callback(HttpError.badRequest(errorMessage || 'Bad header format'));
				    }

				    // Verify required header attributes

				    if (!attributes.id ||
				        !attributes.ts ||
				        !attributes.nonce ||
				        !attributes.mac) {

				        return callback(HttpError.badRequest('Missing attributes'), null, attributes);
				    }

				    // Check timestamp staleness

				    if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
				        return callback(HttpError.unauthorized('Stale timestamp', 'Hawk', { ts: now }), null, attributes);
				    }

				    // Fetch Hawk credentials

				    credentialsFunc(attributes.id, function (err, credentials) {

				        if (err) {
				            return callback(err, credentials || null, attributes);
				        }

				        if (!credentials) {
				            return callback(HttpError.unauthorized('Unknown credentials', 'Hawk'), null, attributes);
				        }

				        if (!credentials.key ||
				            !credentials.algorithm) {

				            return callback(HttpError.internal('Invalid credentials'), credentials, attributes);
				        }

				        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
				            return callback(HttpError.internal('Unknown algorithm'), credentials, attributes);
				        }

				        // Calculate MAC

				        var mac = Crypto.calculateMac({
				            type: 'header',
				            key: credentials.key,
				            algorithm: credentials.algorithm,
				            timestamp: attributes.ts,
				            nonce: attributes.nonce,
				            method: request.method,
				            uri: request.url,
				            host: request.host,
				            port: request.port,
				            hash: attributes.hash,
				            ext: attributes.ext
				        });

				        if (!Crypto.fixedTimeComparison(mac, attributes.mac)) {
				            return callback(HttpError.unauthorized('Bad mac', 'Hawk'), credentials, attributes);
				        }

				        // Check payload hash

				        if (options.payload !== null &&
				            options.payload !== undefined) {       // '' is valid

				            if (!attributes.hash) {
				                return callback(HttpError.unauthorized('Missing required payload hash', 'Hawk'), credentials, attributes);
				            }

				            var hash = Crypto.calculateHash(options.payload, credentials.algorithm);
				            if (!Crypto.fixedTimeComparison(hash, attributes.hash)) {
				                return callback(HttpError.unauthorized('Bad payload hash', 'Hawk'), credentials, attributes);
				            }
				        }

				        // Check nonce

				        options.nonceFunc(attributes.nonce, attributes.ts, function (err) {

				            if (err) {
				                return callback(HttpError.unauthorized('Invalid nonce', 'Hawk'), credentials, attributes);
				            }

				            // Successful authentication

				            return callback(null, credentials, attributes);
				        });
				    });
				};


				// Generate an Authorization header for a given request

				/*
				 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
				 * options is an object with the following optional keys: 'ext', 'timestamp', 'nonce', 'localtimeOffsetMsec', 'payload'
				 */

				exports.getAuthorizationHeader = function (credentials, method, uri, host, port, options) {

				    options = options || {};
				    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

				    // Application time

				    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

				    // Check request
				    if (!credentials.id ||
				        !credentials.key ||
				        !credentials.algorithm) {

				        // Invalid credential object
				        return '';
				    }

				    // convert to uppercase since that's how cryptoJS references algos  
				    credentials.algorithm = credentials.algorithm.toUpperCase();

				    if (Crypto.algorithms.indexOf(credentials.algorithm) < 0) {
				        return '';
				    }

				    // Calculate payload hash

				    var hash = null;
				    if (options.payload !== null &&
				        options.payload !== undefined) {

				        hash = Crypto.calculateHash(options.payload, credentials.algorithm);
				    }

				    // Calculate signature

				    var artifacts = {
				        type: 'header',
				        key: credentials.key,
				        algorithm: credentials.algorithm,
				        timestamp: options.timestamp || Math.floor(now / 1000),
				        nonce: options.nonce || Crypto.randomString(6),
				        method: method,
				        uri: uri,
				        host: host,
				        port: port,
				        hash: hash,
				        ext: options.ext
				    };

				    var mac = Crypto.calculateMac(artifacts);

				    // Construct header

				    var header = 'Hawk id="' + credentials.id +
				                 '", ts="' + artifacts.timestamp +
				                 '", nonce="' + artifacts.nonce +
				                 (hash ? '", hash="' + hash : '') +
				                 (options.ext ? '", ext="' + Utils.escapeHeaderAttribute(options.ext) : '') +
				                 '", mac="' + mac + '"';

				    return header;
				};


				// Validate payload hash

				exports.validatePayload = function (payload, credentials, hash) {

				    var calculatedHash = Crypto.calculateHash(payload, credentials.algorithm);
				    return Crypto.fixedTimeComparison(calculatedHash, hash);
				};

			},
			"httpError.js": function (exports, module, require) {
				// Load modules

				var Utils = require('./utils');


				/*
				    HttpError(new Error)
				    HttpError(code, message)
				*/

				function HttpError() {
				    if(!(this instanceof HttpError))
				        return new HttpError.apply(null,arguments);

				    var self = this;

				    Error.call(this);
				    this.isError = true;

				    this.response = {
				        code: 0,
				        payload: {},
				        headers: {}
				        // type: 'content-type'
				    };

				    if (arguments[0] instanceof Error) {

				        // Error

				        var error = arguments[0];

				        this.data = error;
				        this.response.code = error.code || 500;
				        if (error.message) {
				            this.message = error.message
				        }
				    }
				    else {

				        // code, message

				        var code = parseInt(arguments[0],10);
				        var message = arguments[1];

				        /* Assertion seems superfluos */
				        //Utils.assert(!isNaN(code) || code < 400, 'Invalid Error code: ' + code);

				        this.response.code = code;
				        if (message) {
				            this.message = message
				        }
				    }

				    // Response format

				    this.reformat();

				    return this;
				};

				Utils.inherit(HttpError, Error);


				HttpError.prototype.reformat = function () {

				    this.response.payload.code = this.response.code;
				    this.response.payload.error = HttpError.STATUS_CODES[this.response.code] || 'Unknown';
				    if (this.message) {
				        this.response.payload.message = this.message;
				    }
				};


				// Utilities

				HttpError.badRequest = function (message) {

				    return new HttpError(400, message);
				};


				HttpError.unauthorized = function (error, scheme, attributes) {           // Or function (error, wwwAuthenticate[])

				    var err = new HttpError(401, error);

				    if (!scheme) {
				        return err;
				    }

				    var wwwAuthenticate = '';

				    if (typeof scheme === 'string') {

				        // function (error, scheme, attributes)

				        wwwAuthenticate = scheme;
				        if (attributes) {
				            var names = Object.keys(attributes);
				            for (var i = 0, il = names.length; i < il; ++i) {
				                if (i) {
				                    wwwAuthenticate += ',';
				                }

				                var value = attributes[names[i]];
				                if (value === null ||
				                    value === undefined) {              // Value can be zero

				                    value = '';
				                }
				                wwwAuthenticate += ' ' + names[i] + '="' + Utils.escapeHeaderAttribute(value.toString()) + '"';
				            }
				        }

				        if (error) {
				            if (attributes) {
				                wwwAuthenticate += ',';
				            }
				            wwwAuthenticate += ' error="' + Utils.escapeHeaderAttribute(error) + '"';
				        }
				        else {
				            err.isMissing = true;
				        }
				    }
				    else {

				        // function (error, wwwAuthenticate[])

				        var wwwArray = scheme;
				        for (var i = 0, il = wwwArray.length; i < il; ++i) {
				            if (i) {
				                wwwAuthenticate += ', ';
				            }

				            wwwAuthenticate += wwwArray[i];
				        }
				    }

				    err.response.headers['WWW-Authenticate'] = wwwAuthenticate;

				    return err;
				};


				HttpError.clientTimeout = function (message) {

				    return new HttpError(408, message);
				};


				HttpError.serverTimeout = function (message) {

				    return new HttpError(503, message);
				};


				HttpError.forbidden = function (message) {

				    return new HttpError(403, message);
				};


				HttpError.notFound = function (message) {

				    return new HttpError(404, message);
				};


				HttpError.internal = function (message, data) {

				    var err = new HttpError(500, message);
				    err.data = data;
				    err.response.payload.message = 'An internal server error occurred';                     // Hide actual error from user

				    return err;
				};


				HttpError.passThrough = function (code, payload, contentType, headers) {

				    var err = new HttpError(500, 'Pass-through');                                      // 500 code is only used to initialize

				    err.data = {
				        code: code,
				        payload: payload,
				        type: contentType
				    };

				    err.response.code = code;
				    err.response.type = contentType;
				    err.response.headers = headers;
				    err.response.payload = payload;

				    return err;
				};

				HttpError.STATUS_CODES = {
				    "100": "Continue",
				    "101": "Switching Protocols",
				    "102": "Processing",
				    "200": "OK",
				    "201": "Created",
				    "202": "Accepted",
				    "203": "Non-Authoritative Information",
				    "204": "No Content",
				    "205": "Reset Content",
				    "206": "Partial Content",
				    "207": "Multi-Status",
				    "208": "Already Reported",
				    "226": "IM Used",
				    "300": "Multiple Choices",
				    "301": "Moved Permanently",
				    "302": "Found",
				    "303": "See Other",
				    "304": "Not Modified",
				    "305": "Use Proxy",
				    "306": "Reserved",
				    "307": "Temporary Redirect",
				    "308": "Permanent Redirect",
				    "400": "Bad Request",
				    "401": "Unauthorized",
				    "402": "Payment Required",
				    "403": "Forbidden",
				    "404": "Not Found",
				    "405": "Method Not Allowed",
				    "406": "Not Acceptable",
				    "407": "Proxy Authentication Required",
				    "408": "Request Timeout",
				    "409": "Conflict",
				    "410": "Gone",
				    "411": "Length Required",
				    "412": "Precondition Failed",
				    "413": "Request Entity Too Large",
				    "414": "Request-URI Too Long",
				    "415": "Unsupported Media Type",
				    "416": "Requested Range Not Satisfiable",
				    "417": "Expectation Failed",
				    "422": "Unprocessable Entity",
				    "423": "Locked",
				    "424": "Failed Dependency",
				    "425": "Reserved for WebDAV advanced collections expired proposal",
				    "426": "Upgrade Required",
				    "427": "Unassigned",
				    "428": "Precondition Required",
				    "429": "Too Many Requests",
				    "430": "Unassigned",
				    "431": "Request Header Fields Too Large",
				    "500": "Internal Server Error",
				    "501": "Not Implemented",
				    "502": "Bad Gateway",
				    "503": "Service Unavailable",
				    "504": "Gateway Timeout",
				    "505": "HTTP Version Not Supported",
				    "506": "Variant Also Negotiates (Experimental)",
				    "507": "Insufficient Storage",
				    "508": "Loop Detected",
				    "509": "Unassigned",
				    "510": "Not Extended",
				    "511": "Network Authentication Required"
				};

				exports = module.exports = HttpError;
			},
			"utils.js": function (exports, module, require) {
				
				// Extract host and port from request

				exports.parseHost = function (req, hostHeaderName) {

				    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
				    var hostHeader = req.headers[hostHeaderName];
				    if (!hostHeader) {
				        return null;
				    }

				    var hostHeaderRegex = /^(?:(?:\r\n)?[\t ])*([^:]+)(?::(\d+))?(?:(?:\r\n)?[\t ])*$/;     // Does not support IPv6
				    var hostParts = hostHeader.match(hostHeaderRegex);

				    if (!hostParts ||
				        hostParts.length !== 3 ||
				        !hostParts[1]) {

				        return null;
				    }

				    return {
				        name: hostParts[1],
				        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
				    };
				};


				// Convert node's  to request configuration object

				exports.parseRequest = function (req, options) {

				    if (!req.headers) {
				        return req;
				    }

				    // Obtain host and port information

				    var host = exports.parseHost(req, options.hostHeaderName);
				    if (!host) {
				        return new Error('Invalid Host header');
				    }

				    var req = {
				        method: req.method,
				        url: req.url,
				        host: host.name,
				        port: host.port,
				        authorization: req.headers.authorization
				    };

				    return req;
				};


				exports.parseURL = function(str) {
				    var url = /^(?:([A-Za-z]+):)(\/{0,3})(?:([^\x00-\x1F\x7F:]+)?:?([^\x00-\x1F\x7F:]*)@)?([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^\x00-\x1F\x7F]+))?$/,
				        u = url.exec(str);
				    if(!u) return false;
				    var path = /^([\w\-]+)?(?:#([\w\-]+))?(?:\:([\w\-]+))?(?:\?(.*))?$/,
				        p = u[7] ? path.exec(u[7]) : null;    
				    return u ? {uriparts:u,
				        protocol:u[1],
				        username:u[3],
				        password:u[4],
				        hostname:u[5],
				        port:u[6],
				        path:p?{
				            first:p[1],
				            hash:p[2],
				            base:p[3],
				            query:p[4],
				            string:u[7]
				        }:u[7]} : false;   
				}


				exports.now = function () {

				    return Date.now();
				};


				exports.inherit = function(self, parent) {
				    self.super_ = parent;
				    self.prototype = Object.create(parent.prototype, {
				            constructor: {
				                value: self,
				                enumerable: false,
				                writable: true,
				                configurable: true
				            }
				        });
				};


				// Escape attribute value for use in HTTP header

				exports.escapeHeaderAttribute = function (attribute) {

				    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
				};
			}
		}
	}
})("hawk/index");
});
